<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta charset="UTF-8">
    <meta name="Description" content="模様生成">
    <title>模様生成</title>
  </head>
  <body>
    <script src="gls3.js"></script>
    <script type="module">
import TComponent from '../../../TComponent/TComponent.mjs'

function Math_mod (a, b) {
  const c = a % b
  return c < 0 ? c + b : c
}

function Math_mean (...arr) {
  return arr.reduce((s, v) => s + v) / arr.length
}

class XorShift32star {
  constructor (seed = Date.now()) {
    this.y = seed >>> 0
    if (this.y === 0) this.y = 0x7d68d45f
  }
  next () {
    this.y ^= this.y << 13
    this.y ^= this.y >>> 17
    this.y ^= this.y << 15
    return ((this.y >>> 0) * 0x92F8B >>> 0) / 0x100000000
  }
  irand (min, max) {
    return Math.floor(this.next() * (max - min + 1) + min)
  }
}

class MyRand {
  constructor (xos) {
    this.counter = -1
    this.m = xos.irand(1, 2)
    this.arr = Array(xos.irand(2, 7)).fill().map(() =>
      Array(6).fill().reduce(s => s + xos.next(), 0) - 3
    )
  }
  next () {
    if (++this.counter >= this.arr.length) this.counter -= this.m
    return this.arr[this.counter]
  }
}

class MyNoise {
  constructor (reso, xos) {
    this.rand = new MyRand(xos)
    this.arr = new Float32Array(reso * reso)
    this.min = 0
    this.max = 0
    this.reso = reso
    this.draw(0, 0, 1, 0)
  }
  getPixel (x, y) {
    const p = Math_mod(Math.floor(x), this.reso) + Math_mod(Math.floor(y), this.reso) * this.reso
    return this.arr[p]
  }
  draw (x, y, s, n) {
    if (s >= this.reso) {
      const tmp = Math.log(n) / Math.LN2 + 1
      const a = Math.pow(2, -tmp >> 1) * this.reso
      const b = tmp & 1 && a
      const mean = Math_mean(
        this.getPixel(x - a, y - b),
        this.getPixel(x + b, y - a),
        this.getPixel(x - b, y + a),
        this.getPixel(x + a, y + b),
      )
      const sigma = Math.sqrt(a * a + b * b)
      const val = this.rand.next() * sigma + mean
      if (this.min > val) this.min = val
      if (this.max < val) this.max = val
      this.arr[x + y * this.reso] = val
      return
    }
    const s2 = s * 2, n4 = n * 4
    this.draw(x, y, s2, n4)
    this.draw(x + s, y + s, s2, n4 + 1)
    this.draw(x + s, y, s2, n4 + 2)
    this.draw(x, y + s, s2, n4 + 3)
  }
  getVal (i) {
    return (this.arr[i] - this.min) / (this.max - this.min)
  }
}

class Main {
  constructor (canvas) {
    this.gl = new Gls(canvas, { alpha: false, depth: false, antialias: false })
    this.gl.clearColor(1, 1, 1, 1)
    this.program = this.gl.createProgram(`
      attribute float id;
      void main() {
          gl_Position = vec4(vec2(mod(id, 2.0), floor(id / 2.0)) * 2.0 - 1.0, 0.0, 1.0);
      }
    `, `
      precision mediump float;
      const vec3 hue = vec3(0.0, 2.0 / 3.0, 1.0 / 3.0);
      uniform sampler2D texture;
      uniform float reso;
      uniform float hueOffset;
      uniform float vxOffset;
      uniform float vyOffset;
      uniform vec2  lightnessOffset;

      vec4 hsla(vec4 c) {
          float s = clamp(c.y, 0.0, 1.0);
          float l = clamp(c.z, 0.0, 1.0);

          vec2 range = vec2(-1.0, 1.0) * s + 1.0;
          if (l < 0.5) {
              range = l * range;
          } else {
              range = 1.0 - (l - 1.0) * (range - 2.0);
          }

          vec3 rgb = clamp(abs(fract(c.x + hue) * 6.0 - 3.0) - 1.0, 0.0, 1.0);
          return vec4(rgb * (range.y - range.x) + range.x, c.w);
      }

      float getVal(vec2 p) {
          p += gl_FragCoord.xy * vec2(1.0, -1.0) / reso;
          vec2 c = texture2D(texture, p).rg;
          return c.g + c.r / 256.0;
      }

      void main() {
          float vx = getVal(vec2(vxOffset, 0.0));
          float vy = getVal(vec2(0.0, vyOffset));

          float hue = getVal(vec2(vx, vy)) + hueOffset;
          float lightness = sin(getVal(vec2(vx, vy) + lightnessOffset) * 10.0) / 4.0 + 0.9;

          gl_FragColor = hsla(vec4(hue, 0.65, lightness, 1.0));
          //gl_FragColor = hsla(vec4(0.7, 0.5, getVal(vec2(0.0)), 1.0));
      }
    `)
    this.geom = this.gl.createGeometry([this.program])
    this.geom.allocate(4, null, vertices =>
      vertices.forEach((attribute, id) => attribute.id = id)
    )
    this.gl.clear()
  }
  draw (reso, seed) {
    const begin = Date.now()

    this.gl.canvas.width = this.gl.canvas.height = reso
    this.gl.viewport(0, 0, reso, reso)

    const xos = new XorShift32star(seed)

    this.program.uniform.reso = reso
    this.program.uniform.texture = this._createTexture(reso, xos)
    this.program.uniform.hueOffset = xos.next()
    this.program.uniform.vxOffset = xos.next()
    this.program.uniform.vyOffset = xos.next()
    this.program.uniform.lightnessOffset = [xos.next(), xos.next()]
    this.program.draw(this.geom)

    const end = Date.now()
    console.log(end - begin + ' ms')
  }
  _createTexture (reso, xos) {
    const imageData = document.createElement('canvas').getContext('2d').createImageData(reso, reso)
    const d = new Uint32Array(imageData.data.buffer)
    const noise = new MyNoise(reso, xos)
    d.forEach((_v, i) => {
      const v = noise.getVal(i)
      d[i] = Math.min(Math.max(0, Math.floor(v * 65536)), 65535)
    })
    return this.gl.createTexture(imageData, this.gl.NEAREST_REPEAT)
  }
}

function saveBlob (blob, filename = blob.name) {
  if (navigator.msSaveBlob) {
      navigator.msSaveBlob(blob, filename)
  } else {
    const url = URL.createObjectURL(blob)
    document.body.insertAdjacentHTML('beforeend', `<a href="${url}" download="${filename}" hidden></a>`)
    const a = document.body.lastChild
    a.click()
    document.body.removeChild(a)
    setTimeout(URL.revokeObjectURL.bind(URL), 0, url)
  }
}

// http://stackoverflow.com/questions/4998908/convert-data-uri-to-file-then-append-to-formdata
function dataURItoBlob (dataURI) {
  let byteString
  if (dataURI.split(',')[0].indexOf('base64') >= 0) {
    byteString = atob(dataURI.split(',')[1])
  } else {
    byteString = unescape(dataURI.split(',')[1])
  }
  const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]
  const ia = new Uint8Array(byteString.length)
  for (let i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i)
  }
  return new Blob([ia], {type: mimeString})
}

function style (text) {
  const elem = document.createElement('style')
  elem.textContent = text
  document.head.appendChild(elem)
}

class App extends TComponent {
  template () {
    style(`
      body {
        background: white;
      }
      canvas {
        border: 1px solid gray;
      }
      input, button, select {
        font-family: inherit;
        font-size: inherit;
      }
      input[type="number"] {
        text-align: right;
      }
    `)
    return `
      <div>
        <label>
          No.<input id="seedInput" type="number" min="1" max="4294967295" value="1" onclick="this.update()" onkeyup="this.update()" />
        </label>
        <label>サイズ
          <select id="resoSelect" onchange="this.update()">
            <option value="256">小 (256x256)</option>
            <option value="512" selected>中 (512x512)</option>
            <option value="1024">大 (1024x1024)</option>
            <option value="2048">特大 (2048x2048)</option>
          </select>
        </label>
        <button onclick="this.handlePrevButton(event)">前</button>
        <button onclick="this.handleNextButton(event)">次</button>
        <button onclick="this.handleSaveButton(event)">保存</button>
        <br />
        <canvas id="view" width="512" height="512">WebGL is not supported.</canvas>
      </div>
    `
  }
  constructor () {
    super()
    this.main = new Main(this.view)
    this.tid = null
  }
  init () {
    this.update()
  }
  setSeed (seed) {
    this.seedInput.value = Math.min(Math.max(parseInt(this.seedInput.min), parseInt(seed)), parseInt(this.seedInput.max))
  }
  getSeed () {
    return parseInt(this.seedInput.value)
  }
  getReso () {
    return parseInt(this.resoSelect.value)
  }
  handlePrevButton (event) {
    this.setSeed(this.getSeed() - 1)
    this.update()
  }
  handleNextButton (event) {
    this.setSeed(this.getSeed() + 1)
    this.update()
  }
  handleSaveButton (event) {
    const blob = dataURItoBlob(this.view.toDataURL())
    const seed = this.getSeed()
    const reso = this.getReso()
    saveBlob(blob, seed + '-' + reso + '.png')
  }
  update () {
    if (this.tid != null) clearTimeout(this.tid)
    this.tid = setTimeout(() => {
      this.tid = null
      this.main.draw(this.getReso(), this.getSeed())
    }, 0)
  }
}

const app = new App()
document.body.appendChild(app.element)
if (app.init) app.init()
if (app.loop) {
  (function loop (t) {
    window.requestAnimationFrame(loop)
    app.loop(t)
  }(0))
}
window.app = app
    </script>
    <script nomodule src="../../../assets/nomodule.js"></script>
    <noscript><p>Please enable JavaScript in your browser.</p></noscript>
  </body>
</html>