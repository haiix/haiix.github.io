<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <title></title>
  </head>
  <body>
    <canvas id="view" width="400" height="400">
      WebGL is not supported.

      <!-- シャドウマッピング -->
      <script data-name="shadowShader" type="x-shader/x-vertex">
        attribute vec3 position;
        uniform mat4 depthMVP;

        void main() {
            gl_Position = depthMVP * vec4(position, 1.0);
        }
      </script>
      <script data-name="shadowShader" type="x-shader/x-fragment">
        precision mediump float;

        void main() {
            gl_FragColor = vec4(vec3(gl_FragCoord.z), 1.0);
        }
      </script>

      <!-- メイン -->
      <script data-name="mainShader" type="x-shader/x-vertex">
        attribute vec3 position;
        attribute vec3 normal;
        uniform mat4 MVP;
        uniform mat4 depthMVP;
        uniform vec3 lightInvDir;
        varying vec4 shadowCoord;
        varying float vColor;

        void main() {
            gl_Position =  MVP * vec4(position, 1.0);
            shadowCoord = (depthMVP * vec4(position, 1.0)) * 0.5 + 0.5;
            vColor = clamp(dot(normal, lightInvDir), 0.0, 1.0) * 0.75 + 0.65;
        }
      </script>
      <script data-name="mainShader" type="x-shader/x-fragment">
        precision mediump float;

        uniform sampler2D shadowMap;
        uniform float hue;
        varying vec4 shadowCoord;
        varying float vColor;

        vec3 hsv2rgb(float h, float s, float v) {
            s = clamp(s, 0., 1.);
            v = clamp(v, 0., 1.);
            vec3 rgb = h * 6. + vec3(2., 0., 4.);
            rgb = clamp(2. - abs(mod(rgb, 6.) - 2.), 0., 1.);
            rgb = rgb * s + (1. - s);
            rgb = rgb * v;
            return rgb;
        }

        void main() {
            float visibility = 1.0;
            vec2 coord = shadowCoord.xy;
            float z = shadowCoord.z - 0.008;
            float n = 0.003;
            if (texture2D(shadowMap, coord).z < z) { visibility -= 0.1; }
            if (texture2D(shadowMap, coord + vec2(n, 0.0)).z < z) { visibility -= 0.05; }
            if (texture2D(shadowMap, coord + vec2(-n, n)).z < z) { visibility -= 0.05; }
            if (texture2D(shadowMap, coord + vec2(-n, -n)).z < z) { visibility -= 0.05; }

            gl_FragColor = vec4(hsv2rgb(hue, 0.5, min(visibility, vColor)), 1.0);
        }
      </script>
    </canvas>
    <script src="gl-matrix-min.js"></script>
    <script src="gls3.js"></script>
    <script src="gls3-lib.js"></script>
    <!--<script src="gls3-dev.js"></script>-->
    <script>
'use strict';

var gl = new Gls('#view', {alpha: false, depth: true, antialias: true});

// シャドウマップ
gl.mainShader.uniform.shadowMap = gl.createFramebuffer({
  width: 512,
  height: 512,
  //depth: true,
  texture: gl.LINEAR_CLAMP,
});

// 光源
var lightInvDir = vec3.fromValues(5, 10, 20);
vec3.normalize(lightInvDir, lightInvDir);
gl.mainShader.uniform.lightInvDir = lightInvDir;
// 光源の視点
var depthVP = function (range) {
  var depthProjectionMatrix = mat4.create();
  mat4.ortho(depthProjectionMatrix, -range, range, -range, range, -range, range);
  var depthViewMatrix = mat4.create();
  mat4.lookAt(depthViewMatrix, lightInvDir, vec3.fromValues(0, 0, 0), vec3.fromValues(0, 0, 1));
  var depthVP = mat4.create();
  mat4.mul(depthVP, depthProjectionMatrix, depthViewMatrix);
  return depthVP;
}(15);

// モデル作成
var floorGeom = gl.createGeometry([gl.shadowShader, gl.mainShader], gl.TRIANGLE_STRIP);
var floorMesh = floorGeom.createMesh(1, 1);
floorMesh.transform(function (attribute) {
  // 床
  var p = attribute.position;
  var n = attribute.normal;

  p.x *= 8;
  p.y *= 8;
  p.z = -1;

  n.z = 1;
});
var ballGeom = gl.createGeometry([gl.shadowShader, gl.mainShader], gl.TRIANGLE_STRIP);
var ballMesh = ballGeom.createMesh(32, 32);
ballMesh.transform(function (attribute) {
  var p = attribute.position;
  var n = attribute.normal;

  var l = Math.cos(p.y * Math.PI / 2);
  p.z = Math.sin(p.y * Math.PI / 2);
  p.y = Math.sin(p.x * Math.PI) * l;
  p.x = Math.cos(p.x * Math.PI) * l;

  n.x = p.x;
  n.y = p.y;
  n.z = p.z;
});

// モデル描画
function drawGeoms(prog, VP, time) {
  // 床
  prog.uniform.MVP = VP; 
  prog.uniform.hue = 1 / 12;
  prog.uniform.depthMVP = depthVP;
  prog.draw(floorGeom);

  // ボール
  for (var i = 0; i < 16; i++) {
    var x = Math.cos(i) * Math.sqrt(i * 3);
    var y = Math.sin(i) * Math.sqrt(i * 3);
    var z = Math.abs(Math.sin(i * 2 + time / 500)) * 5;

    var M = mat4.create();
    var translation = vec3.fromValues(x, y, z);
    var rotation = quat.create();
    mat4.fromRotationTranslation(M, rotation, translation);

    var MVP = mat4.create();
    mat4.mul(MVP, VP, M);
    prog.uniform.MVP = MVP;
    prog.uniform.hue = i / 7.5;

    var depthMVP = mat4.create();
    mat4.mul(depthMVP, depthVP, M);
    prog.uniform.depthMVP = depthMVP;

    prog.draw(ballGeom);
  }
}

var camera = gl.createCamera = gl.createCamera({fov: 45, near: 0.1, far: 100, z: 20});

// マウス制御処理を作成
gl.mouse = gl.createMouse({
  delay: 0.9,
});

!function loop(time) {
  requestAnimationFrame(loop);
  gl.mouse.update();

  var VP = camera({pan: gl.mouse.dispX * 180, tilt: gl.mouse.dispY * -90, roll: 0});
  var M = mat4.fromRotation(mat4.create(), -Math.PI / 2, vec3.fromValues(1, 0, 0)); // Y軸とZ軸を入れ替え
  VP = mat4.mul(mat4.create(), VP, M);

  gl.bindFramebuffer(gl.mainShader.uniform.shadowMap);
  gl.enable(gl.CULL_FACE);
  gl.clearColor(1, 1, 1, 1);
  gl.gl.clearDepth(1);
  gl.clear();
  drawGeoms(gl.shadowShader, VP, time);
  //gl.disable(gl.CULL_FACE);

  gl.bindFramebuffer(null);
  //gl.enable(gl.CULL_FACE);
  gl.clearColor(0.4, 0.3, 0.2, 1);
  gl.gl.clearDepth(1);
  gl.clear();
  drawGeoms(gl.mainShader, VP, time);
  gl.disable(gl.CULL_FACE);
}(0);

    </script>
  </body>
</html>