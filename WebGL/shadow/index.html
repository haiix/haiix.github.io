<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <title></title>
  </head>
  <body>
    <canvas id="view" width="400" height="400"></canvas>
    <script src="gl-matrix-min.js"></script>
    <script type="module">
import Gls from './Gls-lib.mjs'

const gl = new Gls('#view', {alpha: false, depth: true, antialias: true})

gl.mainShader = gl.createProgram(`
  attribute vec3 position;
  attribute vec3 normal;
  uniform mat4 MVP;
  uniform mat4 depthMVP;
  uniform vec3 lightInvDir;
  varying vec4 shadowCoord;
  varying float vColor;

  void main() {
    gl_Position =  MVP * vec4(position, 1.0);
    shadowCoord = (depthMVP * vec4(position, 1.0)) * 0.5 + 0.5;
    vColor = clamp(dot(normal, lightInvDir), 0.0, 1.0) * 0.75 + 0.65;
  }
`, `
  precision mediump float;

  uniform sampler2D shadowMap;
  uniform float hue;
  varying vec4 shadowCoord;
  varying float vColor;

  vec3 hsv2rgb(float h, float s, float v) {
    s = clamp(s, 0., 1.);
    v = clamp(v, 0., 1.);
    vec3 rgb = h * 6. + vec3(2., 0., 4.);
    rgb = clamp(2. - abs(mod(rgb, 6.) - 2.), 0., 1.);
    rgb = rgb * s + (1. - s);
    rgb = rgb * v;
    return rgb;
  }

  void main() {
    float visibility = 1.0;
    vec2 coord = shadowCoord.xy;
    float z = shadowCoord.z - 0.008;
    float n = 0.003;
    if (texture2D(shadowMap, coord).z < z) { visibility -= 0.1; }
    if (texture2D(shadowMap, coord + vec2(n, 0.0)).z < z) { visibility -= 0.05; }
    if (texture2D(shadowMap, coord + vec2(-n, n)).z < z) { visibility -= 0.05; }
    if (texture2D(shadowMap, coord + vec2(-n, -n)).z < z) { visibility -= 0.05; }

    gl_FragColor = vec4(hsv2rgb(hue, 0.5, min(visibility, vColor)), 1.0);
  }
`)

gl.shadowShader = gl.createProgram(`
  attribute vec3 position;
  uniform mat4 depthMVP;

  void main() {
      gl_Position = depthMVP * vec4(position, 1.0);
  }
`, `
  precision mediump float;

  void main() {
      gl_FragColor = vec4(vec3(gl_FragCoord.z), 1.0);
  }
`)


// シャドウマップ
gl.mainShader.uniform.shadowMap = gl.createFramebuffer({
  width: 512,
  height: 512,
  //depth: true,
  texture: gl.LINEAR_CLAMP,
})

// 光源
const lightInvDir = vec3.fromValues(5, 10, 20)
vec3.normalize(lightInvDir, lightInvDir)
gl.mainShader.uniform.lightInvDir = lightInvDir
// 光源の視点
const depthVP = (range => {
  const depthProjectionMatrix = mat4.create()
  mat4.ortho(depthProjectionMatrix, -range, range, -range, range, -range, range)
  const depthViewMatrix = mat4.create()
  mat4.lookAt(depthViewMatrix, lightInvDir, vec3.fromValues(0, 0, 0), vec3.fromValues(0, 0, 1))
  const depthVP = mat4.create()
  mat4.mul(depthVP, depthProjectionMatrix, depthViewMatrix)
  return depthVP
})(15)

// モデル作成
const floorGeom = gl.createGeometry([gl.shadowShader, gl.mainShader], gl.TRIANGLE_STRIP)
const floorMesh = floorGeom.addMesh(1, 1, attribute => {
  // 床
  const p = attribute.position
  const n = attribute.normal

  p.x *= 8
  p.y *= 8
  p.z = -1

  n.z = 1
})
const ballGeom = gl.createGeometry([gl.shadowShader, gl.mainShader], gl.TRIANGLE_STRIP)
const ballMesh = ballGeom.addMesh(32, 32, attribute => {
  const p = attribute.position
  const n = attribute.normal

  const l = Math.cos(p.y * Math.PI / 2)
  p.z = Math.sin(p.y * Math.PI / 2)
  p.y = Math.sin(p.x * Math.PI) * l
  p.x = Math.cos(p.x * Math.PI) * l

  n.x = p.x
  n.y = p.y
  n.z = p.z
})

// モデル描画
function drawGeoms(prog, VP, time) {
  // 床
  prog.uniform.MVP = VP
  prog.uniform.hue = 1 / 12
  prog.uniform.depthMVP = depthVP
  prog.draw(floorGeom)

  // ボール
  for (let i = 0; i < 16; i++) {
    const x = Math.cos(i) * Math.sqrt(i * 3)
    const y = Math.sin(i) * Math.sqrt(i * 3)
    const z = Math.abs(Math.sin(i * 2 + time / 500)) * 5

    const M = mat4.create()
    const translation = vec3.fromValues(x, y, z)
    const rotation = quat.create()
    mat4.fromRotationTranslation(M, rotation, translation)

    const MVP = mat4.create()
    mat4.mul(MVP, VP, M)
    prog.uniform.MVP = MVP
    prog.uniform.hue = i / 7.5

    const depthMVP = mat4.create()
    mat4.mul(depthMVP, depthVP, M)
    prog.uniform.depthMVP = depthMVP

    prog.draw(ballGeom)
  }
}

const camera = gl.createCamera = gl.createCamera({fov: 45, near: 0.1, far: 100, z: 20})

// マウス制御処理を作成
gl.mouse = gl.createMouse({
  delay: 0.9,
})

;(function loop(time) {
  requestAnimationFrame(loop)
  gl.mouse.update()

  let VP = camera({pan: gl.mouse.dispX * 180, tilt: gl.mouse.dispY * -90, roll: 0})
  const M = mat4.fromRotation(mat4.create(), -Math.PI / 2, vec3.fromValues(1, 0, 0)) // Y軸とZ軸を入れ替え
  VP = mat4.mul(mat4.create(), VP, M)

  gl.bindFramebuffer(gl.mainShader.uniform.shadowMap)
  gl.enable(gl.CULL_FACE)
  gl.clearColor(1, 1, 1, 1)
  gl.gl.clearDepth(1)
  gl.clear()
  drawGeoms(gl.shadowShader, VP, time)
  //gl.disable(gl.CULL_FACE)

  gl.bindFramebuffer(null)
  //gl.enable(gl.CULL_FACE)
  gl.clearColor(0.4, 0.3, 0.2, 1)
  gl.gl.clearDepth(1)
  gl.clear()
  drawGeoms(gl.mainShader, VP, time)
  gl.disable(gl.CULL_FACE)
}(0))

    </script>
  </body>
</html>