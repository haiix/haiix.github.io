<!DOCTYPE html>
<meta charset="UTF-8" />
<script type="module">
import TComponent from '../TComponent/TComponent.mjs'
import style from '../assets/style.mjs'
import initApp from '../assets/initApp.mjs'

/**
 * Run the JavaScript code on the worker.
 *
 * @async
 * @function execCode
 * @param {string} code - The JavaScript code.
 * @param {Object} [option] - Options.
 * @param {AbortSignal} [option.signal] - The AbortSignal.
 * @param {number} [option.timeout] - Timeout (ms).
 * @return {Promise<string|ImageData>} The resulting string or ImageData.
 * @throws {Error}
 */
const execCode = (() => {
  const createWorker = ({ oncreate, onmessage, options }) => {
    const objectURL = URL.createObjectURL(new Blob([`'use strict';((self,postMessage,addEventListener)=>{(${oncreate})();addEventListener('message',${onmessage})})(self,postMessage.bind(self),addEventListener.bind(self))`], { type: 'text/javascript' }))
    return [objectURL, new Worker(objectURL, options)]
  }

  const createExecWorker = () => createWorker({
    options: { type: 'classic', credentials: 'omit' },
    oncreate: () => {
      // グローバル変数のうち、許可する変数のリスト
      const whitelist = [
        'Object', 'Function', 'Array', 'Number', 'Boolean', 'String', 'Symbol', 'Date', 'Promise', 'RegExp', 'JSON', 'Math', 'BigInt',
        'parseFloat', 'parseInt', 'Infinity', 'NaN', 'undefined', 'isFinite', 'isNaN',
        'Error', 'AggregateError', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError',
        'ArrayBuffer', 'Uint8Array', 'Int8Array', 'Uint16Array', 'Int16Array', 'Uint32Array', 'Int32Array', 'Float32Array', 'Float64Array', 'Uint8ClampedArray', 'BigUint64Array', 'BigInt64Array', 'DataView',
        'Map', 'Set', 'WeakMap', 'WeakSet',
        'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent',
        'setTimeout', 'setInterval', 'clearInterval', 'clearTimeout', 'requestAnimationFrame',
        'atob', 'btoa',
        'Intl', 'Proxy', 'Reflect',
        'TextEncoder', 'TextDecoder',
        'FileReaderSync', 'FileReader', 'FileList', 'File', 'Blob',
        'Crypto', 'CryptoKey', 'SubtleCrypto', 'crypto',
        'ImageData',
        //'console' // debug
      ]

      // グローバル変数とプロトタイプ継承から、削除可能なものは削除し、削除できないものは隠す変数に追加
      const hiddenVariableNames = Object.create(null)
      for (let curr = self; curr.constructor !== Object; curr = Object.getPrototypeOf(curr)) {
        for (const [name, descriptor] of Object.entries(Object.getOwnPropertyDescriptors(curr))) {
          if (whitelist.includes(name)) continue
          if (descriptor.configurable) {
            delete curr[name]
          } else {
            hiddenVariableNames[name] = true
          }
        }
      }
      const hiddenVariableNamesArr = Object.keys(hiddenVariableNames)
      //console.log(hiddenVariableNamesArr) // debug

      // (function () {})['constructor']('return self') のような記述によるグローバルへのアクセスを防ぐ
      delete Function.prototype.constructor
      delete Object.getPrototypeOf(function * () {}).constructor
      delete Object.getPrototypeOf(async function () {}).constructor
      delete Object.getPrototypeOf(async function * () {}).constructor

      // Function を置き換える
      const _Function = self.Function
      self.Function = function (...args) {
        const code = args.length > 0 ? (args.pop() + '') : ''
        // 禁止ワード: import
        // importはキーワードであり変数の置き換えができないが、動的インポート「import('url')」を防ぐ必要がある
        const fw = ['import'].filter(s => (code).indexOf(s) >= 0)
        if (fw.length > 0) throw new Error('Forbidden word(s): ' + fw.join())
        const dummyFunc = _Function(...args, code)
        const func = _Function(...(args.concat(hiddenVariableNamesArr)), '"use strict";' + code)
        func.toString = dummyFunc.toString.bind(dummyFunc)
        return func
      }
      self.Function.constructor = _Function.constructor
      self.Function.toString = _Function.toString.bind(_Function)
      _Function.prototype.constructor = self.Function

      // setTimeout, setInterval からグローバルへのアクセスを防ぐ
      for (const fn of ['setTimeout', 'setInterval']) {
        const tmp = self[fn]
        self[fn] = (func, ...rest) => {
          if (func != null) {
            if (typeof func !== 'function') func = new Function(func)
            func = func.bind(void 0)
          }
          return tmp(func, ...rest)
        }
        self[fn].toString = tmp.toString.bind(tmp)
      }

      // グローバル変数凍結
      for (const name of whitelist) {
        if (!(name in self) || self[name] == null) continue
        Object.freeze(self[name])
        Object.freeze(self[name].prototype)
      }
    },

    onmessage: async function (event) {
      try {
        // 実行
        let retVal = await new Function(event.data)()
        if (retVal instanceof ImageData) {
          if (retVal.width > 256 || retVal.height > 256) {
            throw new Error('Too large ImageData')
          }
        } else {
          retVal = '' + JSON.stringify(retVal, (key, val) => typeof val === 'function' ? val + '' : (val != null && !Array.isArray(val) && typeof val !== 'string' && typeof val[Symbol.iterator] === 'function') ? Array.from(val) : val)
          retVal = retVal.length < 1000 ? retVal : retVal.slice(0, 997) + '...'
        }
        postMessage(['resolve', retVal])
      } catch (error) {
        const retVal = '[' + error.name + '] ' + error.message
        postMessage(['reject', retVal.length < 1000 ? retVal : retVal.slice(0, 997) + '...'])
      }
    }
  })

  {
    let proc = null, objectURL, worker, timeout
    function initialize () {
      if (worker) return
      ;[objectURL, worker] = createExecWorker()
      worker.onmessage = event => {
        clearTimeout(timeout)
        const [type, value] = event.data
        if (!proc) return
        const [resolve, reject] = proc
        proc = null
        if (type === 'resolve') {
          resolve(value)
        } else {
          reject(new Error(value))
        }
      }
    }

    function terminate (message) {
      clearTimeout(timeout)
      if (!worker) return
      worker.terminate()
      worker = null
      URL.revokeObjectURL(objectURL)
      const [resolve, reject] = proc
      proc = null
      reject(new Error(message))
    }

    return (code, option = null) => new Promise((resolve, reject) => {
      if (proc) throw new Error('Currently working.')
      proc = [resolve, reject]
      initialize()
      if (option && option.timeout) {
        timeout = setTimeout(() => terminate('Timeout.'), option.timeout)
      }
      if (option && option.signal) {
        option.signal.addEventListener('abort', event => terminate('Worker terminated by the abort signal.'))
      }
      worker.postMessage(code)
    })
  }
})()



class App extends TComponent {
  template () {
    style(`
      pre {
        background: #EEE;
        color: #000;
        border: 1px solid #999;
        margin: 0;
        padding: 4px;
      }
      textarea {
        width: 400px;
        height: 200px;
      }
    `)
    return `
      <div>
        <div>Code:</div>
        <pre>function () {
  <textarea id="code" oninput="this.handleInputCode(event)" onchange="this.handleInputCode(event)">return 'Hello, World!'</textarea>
}</pre>
        <div>Result:</div>
        <pre id="result"></pre>
      </div>
    `
  }

  constructor (attr = {}, nodes = []) {
    super()
    this.delayTid = null
    this.prevCode = null
    this.prevAbortController = null
    this.canvas = null
    this.ctx = null
  }

  async main () {
    if (this.prevCode === this.code.value) return
    this.prevCode = this.code.value
    if (this.prevAbortController) this.prevAbortController.abort()
    const abortController = new AbortController()
    this.prevAbortController = abortController
    const mtid = setTimeout(() => {
      this.setText('Processing...')
    }, 100)
    try {
      const retVal = await execCode(this.code.value, { signal: abortController.signal, timeout: 10000 })
      if (retVal instanceof ImageData) {
        if (!this.canvas) {
          this.setText('')
          this.canvas = document.createElement('canvas')
          this.result.appendChild(this.canvas)
          this.ctx = this.canvas.getContext('2d')
        }
        this.canvas.width = retVal.width
        this.canvas.height = retVal.height
        this.ctx.putImageData(retVal, 0, 0)
      } else {
        this.setText(retVal)
      }
    } catch (error) {
      this.setText(error.message, '#F00')
    } finally {
      clearTimeout(mtid)
      if (this.prevAbortController === abortController) {
        this.prevAbortController = null
      }
    }
  }

  setText (text, color = '#000') {
    this.result.textContent = text
    this.canvas = null
    this.ctx = null
    this.result.style.color = color
  }

  handleInputCode (event) {
    clearTimeout(this.delayTid)
    this.delayTid = setTimeout(() => this.main(), 100)
  }
}

initApp(App)
</script>
<script nomodule src="/assets/nomodule.js"></script>